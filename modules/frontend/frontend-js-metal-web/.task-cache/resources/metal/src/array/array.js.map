{"version":3,"sources":["D:/Projects/Liferay/portal/modules/frontend/frontend-js-metal-web/bower_components/metal/src/array/array.js"],"names":[],"mappings":";AAAA,aAAY,CAAC;;;;;;;;;;KAIP,KAAK;WAAL,KAAK;yBAAL,KAAK;;;eAAL,KAAK;;;;;;;;;UAOE,eAAC,IAAI,EAAE,IAAI,EAAE;AACxB,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,SAAI,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE;AACxB,aAAO,KAAK,CAAC;MACb;KACD;AACD,WAAO,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC;IACnC;;;;;;;;;UAOuB,2BAAC,GAAG,EAAE;AAC7B,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpC,SAAI,GAAG,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;AACzB,aAAO,GAAG,CAAC,CAAC,CAAC,CAAC;MACd;KACD;IACD;;;;;;;;;;UAQa,iBAAC,GAAG,EAAE,UAAU,EAAE;AAC/B,QAAI,MAAM,GAAG,UAAU,IAAI,EAAE,CAAC;AAC9B,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpC,SAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;AAC1B,WAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;MAC9B,MAAM;AACN,YAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACpB;KACD;AACD,WAAO,MAAM,CAAC;IACd;;;;;;;;;;;UASY,gBAAC,GAAG,EAAE,GAAG,EAAE;AACvB,QAAI,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACzB,QAAI,EAAE,CAAC;AACP,QAAM,EAAE,GAAG,CAAC,IAAI,CAAC,EAAI;AACpB,UAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;KACvB;AACD,WAAO,EAAE,CAAC;IACV;;;;;;;;;;UAQc,kBAAC,GAAG,EAAE,CAAC,EAAE;AACvB,WAAO,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IAC3D;;;;;;;;;;;;;;UAYW,eAAC,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE;AACjC,QAAI,MAAM,GAAG,EAAE,CAAC;AAChB,QAAI,GAAG,GAAG,iBAAK,KAAK,CAAC,OAAO,CAAC,GAAG,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC;AACrD,SAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACjC,WAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;KACpB;AACD,WAAO,MAAM,CAAC;IACd;;;SA1FI,KAAK;;;kBA6FI,KAAK","file":"bower_components/metal/src/array/array.js","sourcesContent":["'use strict';\n\nimport core from '../core';\n\nclass array {\n\t/**\n\t * Checks if the given arrays have the same content.\n\t * @param {!Array<*>} arr1\n\t * @param {!Array<*>} arr2\n\t * @return {boolean}\n\t */\n\tstatic equal(arr1, arr2) {\n\t\tfor (var i = 0; i < arr1.length; i++) {\n\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn arr1.length === arr2.length;\n\t}\n\n\t/**\n\t * Returns the first value in the given array that isn't undefined.\n\t * @param {!Array} arr\n\t * @return {*}\n\t */\n\tstatic firstDefinedValue(arr) {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] !== undefined) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Transforms the input nested array to become flat.\n\t * @param {Array.<*|Array.<*>>} arr Nested array to flatten.\n\t * @param {Array.<*>} opt_output Optional output array.\n\t * @return {Array.<*>} Flat array.\n\t */\n\tstatic flatten(arr, opt_output) {\n\t\tvar output = opt_output || [];\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (Array.isArray(arr[i])) {\n\t\t\t\tarray.flatten(arr[i], output);\n\t\t\t} else {\n\t\t\t\toutput.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Removes the first occurrence of a particular value from an array.\n\t * @param {Array.<T>} arr Array from which to remove value.\n\t * @param {T} obj Object to remove.\n\t * @return {boolean} True if an element was removed.\n\t * @template T\n\t */\n\tstatic remove(arr, obj) {\n\t\tvar i = arr.indexOf(obj);\n\t\tvar rv;\n\t\tif ( (rv = i >= 0) ) {\n\t\t\tarray.removeAt(arr, i);\n\t\t}\n\t\treturn rv;\n\t}\n\n\t/**\n\t * Removes from an array the element at index i\n\t * @param {Array} arr Array or array like object from which to remove value.\n\t * @param {number} i The index to remove.\n\t * @return {boolean} True if an element was removed.\n\t */\n\tstatic removeAt(arr, i) {\n\t\treturn Array.prototype.splice.call(arr, i, 1).length === 1;\n\t}\n\n\t/**\n\t * Slices the given array, just like Array.prototype.slice, but this\n\t * is faster and working on all array-like objects (like arguments).\n\t * @param {!Object} arr Array-like object to slice.\n\t * @param {number} start The index that should start the slice.\n\t * @param {number=} opt_end The index where the slice should end, not\n\t *   included in the final array. If not given, all elements after the\n\t *   start index will be included.\n\t * @return {!Array}\n\t */\n\tstatic slice(arr, start, opt_end) {\n\t\tvar sliced = [];\n\t\tvar end = core.isDef(opt_end) ? opt_end : arr.length;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tsliced.push(arr[i]);\n\t\t}\n\t\treturn sliced;\n\t}\n}\n\nexport default array;\n"],"sourceRoot":"/source/"}