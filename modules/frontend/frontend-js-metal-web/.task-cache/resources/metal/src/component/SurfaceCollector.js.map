{"version":3,"sources":["D:/Projects/Liferay/portal/modules/frontend/frontend-js-metal-web/bower_components/metal/src/component/SurfaceCollector.js"],"names":[],"mappings":";AAAA,aAAY,CAAC;;;;;;;;;;;;;;;;;;;;KAQP,gBAAgB;YAAhB,gBAAgB;;AACV,WADN,gBAAgB,GACP;yBADT,gBAAgB;;AAEpB,8BAFI,gBAAgB,6CAEZ;;;;;;;AAOR,OAAI,CAAC,SAAS,GAAG,EAAE,CAAC;GACpB;;;;;;;;eAVI,gBAAgB;;UAiBX,oBAAC,gBAAgB,EAAE,QAAQ,EAAE;AACtC,QAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE;AACrC,SAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;KAC/C,MAAM;AACN,SAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,QAAQ,CAAC;KAC5C;IACD;;;;;;;UAKc,2BAAG;AACjB,QAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACtB;;;;;;;;;UAOS,oBAAC,gBAAgB,EAAE;AAC5B,WAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC;IAClF;;;;;;;UAKgB,6BAAG;AACnB,QAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACpB;;;;;;;;UAMY,uBAAC,gBAAgB,EAAE;AAC/B,QAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC;IACxC;;;;;;;;;UAOY,uBAAC,gBAAgB,EAAE,QAAQ,EAAE;AACzC,uBAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE,QAAQ,CAAC,CAAC;IACzD;;;SA/DI,gBAAgB;;;kBAkEP,gBAAgB","file":"bower_components/metal/src/component/SurfaceCollector.js","sourcesContent":["'use strict';\n\nimport object from '../object/object';\nimport Disposable from '../disposable/Disposable';\n\n/**\n * Stores surface data to be used later by Components.\n */\nclass SurfaceCollector extends Disposable {\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds all registered surfaces, mapped by their element ids.\n\t\t * @type {!Array<!Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.surfaces_ = {};\n\t}\n\n\t/**\n\t * Adds a surface to this collector.\n\t * @param {string} surfaceElementId\n\t * @param {Object=} opt_data Surface data to be stored.\n\t */\n\taddSurface(surfaceElementId, opt_data) {\n\t\tif (this.surfaces_[surfaceElementId]) {\n\t\t\tthis.updateSurface(surfaceElementId, opt_data);\n\t\t} else {\n\t\t\tthis.surfaces_[surfaceElementId] = opt_data;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.surfaces_ = null;\n\t}\n\n\t/**\n\t * Gets the data for the given surface id.\n\t * @param {string} surfaceElementId\n\t * @return {!Object}\n\t */\n\tgetSurface(surfaceElementId) {\n\t\treturn this.surfaces_[surfaceElementId] ? this.surfaces_[surfaceElementId] : null;\n\t}\n\n\t/**\n\t * Removes all surfaces from this collector.\n\t */\n\tremoveAllSurfaces() {\n\t\tthis.surfaces_ = [];\n\t}\n\n\t/**\n\t * Removes the surface with the given surface id.\n\t * @param {string} surfaceElementId\n\t */\n\tremoveSurface(surfaceElementId) {\n\t\tthis.surfaces_[surfaceElementId] = null;\n\t}\n\n\t/**\n\t * Updates a surface from this collector.\n\t * @param {string} surfaceElementId\n\t * @param {Object=} opt_data Surface data to update the existing data.\n\t */\n\tupdateSurface(surfaceElementId, opt_data) {\n\t\tobject.mixin(this.surfaces_[surfaceElementId], opt_data);\n\t}\n}\n\nexport default SurfaceCollector;\n"],"sourceRoot":"/source/"}